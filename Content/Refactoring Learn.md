# Refactoring Learn

*学习参考书籍《重构》*

如果要给程序添加一个特性，但代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性之后再添加该特性

重构的第一步，确保即将修改的代码拥有可靠的测试代码

编程时，需要遵循营地法则，保证你离开时的代码库一定比来时更健康

好代码的检验标准：人们是否能够轻而易举的修改它，一个健康的代码库能够最大程度的提升我们的生产力，支持更快，更低成本的添加新需求

小改动可以更快前进，请保持代码永远处于可工作状态，小步修改累计起来也能大大改善系统的设计

如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构

肮脏的代码必须重构，但漂亮的代码也需要很多重构

## 重构的原则

### 什么是重构

对程序内部结构进行调整，目的是不改变程序原本行为的前提下，提高其可理解性，降低其修改成本，用更少的工作量创造更大的价值

#### 重构的关键

- 运用大量微小且保持程序原本行为的步骤，一步步达成大规模的修改
- 每个单独的重构要么很小，要么由若干小步骤组合而成
- 重构过程中代码很少进入不可工作状态，即使重构没有完成，也可以在任何时刻停下来

#### 重构与性能优化的相似之处以及区别

相同之处

- 都需要修改代码
- 都不会改变程序的整体功能

区别

- 重构：为了使代码更容易理解，更易于修改，这可能使程序运行的更快，也可能使程序运行的更慢
- 性能优化：只关心让程序运行的更快，最终得到的代码有可能更难理解和维护

### 为什么重构

- 重构有助于代码维持自己该有的形态，改进程序的设计
- 重构可以使程序代码更容易理解
- 重构可以更有效的写出健壮的代码，减少BUG的出现频率
- 重构可以提高编程速度

### 什么时候重构

*三次法则：事不过三，三则重构*

- 预备性重构

  重构的最佳时机就在添加新功能之前，重构后可以使添加新功能更容易

- 帮助理解的重构

  当一段代码不够清晰明了，要花很多时间去读懂这段代码是在做什么的时候，重构后可以使代码更清晰易懂，更容易发现之前看不到的设计问题
  
- 捡垃圾式重构

  可以知道这段代码是在做什么，但发现代码写的不够好的时候，如果这些垃圾代码很容易被重构，就立马重构，如果需要花费一些时间，就先找个地方记下来，在重要任务结束之后再回来重构它，每次经过这段代码时都把它变好一点，积少成多，垃圾总会被处理干净
  
- 有计划的重构、见机行事的重构

  尽可能多的见机行事的重构，降低有计划的重构次数，不要将重构与编程割裂开来
  
- 长期重构

  大多数重构可以在几分钟最多几小时内完成，但有一些大型重构可能要花几个星期，即便在这样的情况下，最好也不要单独找时间来进行重构，可以在未来的几周内逐步解决这些问题
  
- 复审代码时重构

  在编程的过程中持续不断的对代码进行复审，重构可以帮助代码复审

### 什么时候不该重构

- 看到一段凌乱的代码，但并不需要做修改的时候，就不需要重构
- 如果丑陋的代码能被隐藏在一个API之下，就请让它继续丑陋，只有当需要理解其工作原理时，对其重构才有价值
- 重写比重构还容易时，就别重构了

###  代码所有权

当你在重构时需要修改API接口，但这个接口由于各种原因不可以修改时，可以增加新接口并保留旧的接口，同时标记旧接口为不推荐使用

## 代码的坏味道

## 构筑测试体系

## 介绍重构名录

## 第一组重构

## 封装

## 搬移特性

## 重新组织数据

## 简化条件逻辑

## 重构API

## 处理继承关系

